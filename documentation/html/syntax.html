<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>dfh.grammar.Grammar</title>
<link rel="icon" type="image/png" href="/dfh.png" />
<link href="../css/dfh.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="headers.json"></script>
<script type="text/javascript" src="../scripts/pageutils.js"></script>
</head>
<body onLoad="dfh.prepare('syntax', 'dfh.grammar')">
	<h1>Syntax</h1>
	<div>
		A grammar is specified via a formalism similar to a <a
			href="http://en.wikipedia.org/wiki/Backus-Naur_form">Backus-Naur
			Form</a> grammar, though the point of grammars is not to parse BNF
		grammars or express <a
			href="http://en.wikipedia.org/wiki/Context-free_grammar">context-free
			grammars</a> but to create useful character sequence matchers.
		Consequenty, no claims are made as to the purity of grammars as CFGs
		or whatever other theoretical construct. Basically, a grammar is a
		collection of matching rules, where every rule specifies a pattern of
		terminal expressions -- character sequences -- or non-terminal rules.
	</div>
	<span id="toc"></span>
	<h2>General Rules</h2>
	<div>
		Here is the grammar understood by
		<code>dfh.grammar</code>
		expressed in its own formalism:
	</div>
	<pre>                grammar  = [ &lt;padding&gt; ]* [ &lt;rule&gt; [ &lt;padding&gt; ]* ]+

                   rule .= /^/m &lt;rule_name&gt; &lt;eq&gt; &lt;rule_body&gt;
              rule_body  = [ &lt;unbracketed_sequence&gt; | &lt;unbracketed_alternation&gt; ] [ &lt;s&gt; &lt;condition&gt; ]? &lt;rule_end&gt;
unbracketed_alternation  = &lt;element&gt; [ &lt;s&gt; "|" &lt;s&gt; &lt;element&gt; ]+
   unbracketed_sequence  = !&lt;backref&gt; &lt;sequence_element&gt; [ &lt;s&gt; !&lt;up_level_br&gt; &lt;sequence_element&gt; ]*
            alternation  = "[" [ &lt;tags&gt; ]? &lt;s&gt; &lt;element&gt; [ &lt;s&gt; "|" &lt;s&gt; &lt;element&gt; ]+ &lt;s&gt; "]"
              assertion  = &lt;assertion_type&gt; &lt;s&gt; &lt;element&gt;
         assertion_type  = &lt;short_a&gt; | &lt;long_a&gt;
            cnd_element  = &lt;identifier&gt; | &lt;condition&gt;
              condition  = "(" &lt;space&gt;? &lt;cnd_element&gt; [ &lt;cnd_separator&gt; &lt;cnd_element&gt; ]*+ &lt;space&gt;? ")"
                    dot .= "." !&lt;dot&gt;
                element  = &lt;sequence&gt; | &lt;alternation&gt; | &lt;repetition&gt; | &lt;label&gt; | &lt;regex&gt; | &lt;literal&gt; | &lt;up_level_br&gt;
                 long_a  = [ &lt;not&gt; &lt;s&gt; ]? &lt;preposition&gt;
             repetition  = &lt;element&gt; &lt;repetition_suffix&gt;
               rule_end  = [ &lt;s&gt; &lt;comment&gt; ]+ | &lt;space&gt;? &lt;nl&gt;
                      s  = [ &lt;space&gt; | &lt;space&gt;? "\\" &lt;rule_end&gt; ]?
               sequence  = "[" [ &lt;tags&gt; ]?+ &lt;s&gt; !&lt;br&gt; &lt;sequence_element&gt; [ &lt;s&gt; &lt;sequence_element&gt; ]* &lt;s&gt; "]"
       sequence_element  = &lt;element&gt; | &lt;br&gt; | &lt;zero_width&gt; | &lt;dot&gt;
             zero_width  = &lt;barrier&gt; | &lt;assertion&gt;
                backref  = &lt;br&gt; | &lt;up_level_br&gt;
                padding  = &lt;blank_line&gt; | &lt;comment&gt;
      repetition_suffix  = [ &lt;repetition_symbol&gt; | &lt;limits&gt; ] [ &lt;repetition_modifier&gt; ]?
                barrier  = ":"{1,2}
             blank_line .= /^/m &lt;nl&gt;
          cnd_separator  = &lt;space&gt; | &lt;space&gt;? /[&amp;|^]/ &lt;space&gt;?
                comment .= /^/m? /#.*/ &lt;nl&gt;
                  label  = "&lt;" &lt;identifier&gt; "&gt;"
                 limits  = "{" / \d++ | \d++,\d*+ | ,\d++ /x "}"
                literal  = &lt;single_quoted&gt; | &lt;double_quoted&gt;
                    not  = "not" | "!"
                  regex  = /\/ (?: \\ [^\n\r\f] | [^\n\r\f\/] )++ \//x &lt;regex_modifiers&gt;
    repetition_modifier  = "+" | "?"
      repetition_symbol  = "*" | "+" | "?"
              rule_name  = "&lt;"? &lt;identifier&gt; 1
                   tags  = "{" &lt;identifier&gt; [ "," &lt;identifier&gt; ]* "}"
            up_level_br  = &lt;br&gt; "^"
                     br  = /\d++/
          double_quoted  = /" (?: \\ [^\n\r\f] | [^\n\r\f"] )++ "/x
                     eq  = /[.:]?=/
             identifier  = /\w++/
                         # newline according to http://en.wikipedia.org/wiki/Newline, omitting QNX pre-POSIX
                     nl  = /\r\f|\f\r|\r|\f/
            preposition  = "before" | "after"
        regex_modifiers  = /[rimsdux]++/
                short_a  = /[~!][+-]?/
          single_quoted  = /' (?: \\ [^\n\r\f] | [^\n\r\f'] )++ '/x
                  space  = /[\s&amp;&amp;[^\n\r\f]]++/</pre>
	<p>Basically, a grammar expects a set of rules, each of which may
		define a terminal character pattern or a set of constituent rules. The
		matching is top-down: the grammar attempts to match a master rule,
		which generally requires matching constituent rules.</p>
	<h3>Rule</h3>
	<p>
		A rule is composed of two parts: a label and a body. The label must
		match the pattern
		<code>/&lt;\w+&gt;|\w+/</code>
		, that is, a sequence of word characters, optionally surrounded by
		angle brackets. The label is separated from the body by the
		<code>=</code>
		character. The rule body consists of a list of constituent rules and
		may optionally end in a post-match condition and/or comment. If a
		constituent rule is a labeled rule, it is referred to by its label
		inside angle brackets. Some examples:
	<pre>&lt;r1&gt; = 'a'
 r2  = &lt;r1&gt; 'b'
&lt;r3&gt; = /\b regex \b/ix
&lt;r4&gt; = "alt" | "ernation" # a comment
&lt;r5&gt; = 'c' (condition)</pre>
	</p>
	<p>Except in quoting expressions -- a sequence inside a pair of
		angle brackets, single quotes, double quotes, or forward slashes --
		whitespace is ignored, so you can format your rules however you wish;
		but every rule definition must fit on a single line.</p>
	<h3>Root</h3>
	<pre>&lt;label&gt; = 'some' 'rule'</pre>
	<p>Every grammar has a master, or root, rule. This is the rule the
		grammar tries to match against a character sequence. This rule may
		have constituent rules and its constituents may have constituents, but
		these other rules are only invoked as needed in the course of matching
		the root rule. The root rule is a rule like any other: a label
		followed by a definition. It is marked in the grammar only by being
		the first rule listed, though formerly it was required that it bear
		the label &ldquo;ROOT&rdquo; and most of the examples in this
		documentation still follow that convention.</p>
	<h3>Comments</h3>
	<p>
		The grammar parser ignores blank lines. The comment character is
		<code>#</code>
		. If this character appears outside of some quoting construction --
		double or single quotes or the forward slashes bracketing a regular
		expression -- everything after it is ignored.
	<pre>
		
# this and the previous line are ignored
rule = 'a' # and this is ignored as well</pre>
	</p>
	<h2>Usual Bits</h2>
	<h3>Sequence</h3>
	<pre>rule = 'a' 'b'</pre>
	<p>As in Java regular expressions.</p>
	<h3>Alternation</h3>
	<pre>rule = 'a' <b>|</b> 'b'</pre>
	<p>As in Java regular expressions.</p>
	<h3>Repetition</h3>
	<pre>rule = 'a'<b>*</b> 'b'<b>?</b> 'c'<b>+</b> 'd'<b>*?</b> 'e'<b>??</b> 'f'<b>+?</b> 'g'<b>*+</b> 'h'<b>?+</b> 'i'<b>++</b> 'j'<b>{2}</b> 'k'<b>{1,5}?</b> # etc</pre>
	<p>
		As in Java regular expressions. The curly bracket notation accepts
		<code>
			{,<i>n</i>}
		</code>
		as a synonym for
		<code>
			{0,<i>n</i>}
		</code>
		.
	</p>
	<h3>Group</h3>
	<pre>rule1 = <b>[</b> 'a' | 'b' <b>]</b>{3,}+ # the "{3,}+" is just to give the group syntax a purpose
rule2 = <b>[</b> 'a'* 'b' <b>]{1}+</b>   # a non-backtracking group</pre>
	<p>
		Unlike in Java and Perl 5, but following the convention of Perl 6, the
		grouping brackets are not
		<code>()</code>
		but
		<code>[]</code>
		. Round brackets are reserved for conditions. Note that
		<code>dfh.grammar</code>
		lacks its own character class syntax -- for that you must use Java
		native regular expressions. Also, there are no subvarieties of
		grouping expressions as there are in Java and Perl. Every group is a
		capturing group inasmuch as every match retains the entire match tree.
		There are (currently) no in-line match modifiers; for this you must
		rely on native regular expressions. For the equivalent of
		<code>(?&gt;...)</code>
		you must use the repetition suffix
		<code>{1}+</code>
		. Perhaps at some future date I will add a shorthand notation for
		this.
	</p>
	<h3>Back Reference</h3>
	<pre>rule = /["'"]/ /\w++/ <b>1</b> </pre>
	<p>
		Note: no group construct is required but the index is relative to the
		elements <em>of the same sequence</em>. Backreferences of this sort
		are reversible, so you can have, for instance
	</p>
	<pre>foo = [ "'" | '"' ] &lt;bar&gt; 1
bar = <b>not after &lt;foo&gt;</b> &lt;quux&gt;</pre>
	<p>
		This presents the limitation that you can't use branching
		constructions such as
		<code>foo = /['"]/ [ 'a' | 1 ]</code>
		. If this is something you need and you're not worried about
		lookbehinds -- reversible rules -- then you can use the up-level form:
	</p>
	<pre>foo = [ "'" | '"' ] &lt;bar&gt; [ 1<b>^</b> | 'shmoo' ]</pre>
	<p>Now the reference necessarily refers to the main sequence of the
		rule. If this still isn't enough -- you need to refer to a
		sub-sequence or you need to refer a match in another rule -- you will
		need to resort to a condition, though this will cost you efficiency.</p>
	<h2>Terminal Rules</h2>
	<p>
		Terminals rules have no constituent rules. They match against a
		character sequence at some offset or they don't. If a grammar has no
		terminal rules, it never makes contact with the underlying character
		sequence and hence can never match.<span class="fn">This state
			of affairs will be found during compilation and a <code>dfh.grammar.GrammarException</code>
			will be thrown, aborting the program. The exception will carry an
			explanatory message such as "cycle found in rules: &lt;b&gt;,
			&lt;a&gt;".
		</span>
	</p>
	<p>During matching, the matcher will cache some information about
		attempted matches by various rules at various offsets in the character
		sequence. For non-terminal rules all that is cached is the success or
		failure of the match. This is to prevent the cache from consuming too
		much memory -- a particular non-terminal rule can potentially match
		exponentially many ways at a given offset. Because the number of
		possible terminal matches is linear in the length of the sequence, the
		whole match object is stored for terminal matches, accelerating the
		match process.</p>
	<h3>Regular Expressions</h3>
	<pre>rule = <b>/</b>^ foo \b<b>/imx</b> </pre>
	<p>
		Any Java regular expression (aside from multi-line expressions with
		the
		<code>x</code>
		modifier -- everything must be on one line) can be placed inside
		forward slashes and used in a rule. Modifiers can either be included
		inside the slashes like so
	<pre>rule = /(?i:foo)/</pre>
	or appended after the last slash as in Perl.
	<pre>rule = /foo/i</pre>
	</p>
	<h4>Regex modifiers</h4>
	<p>
		Regular expressions can take all the modifiers understood by
		<code>java.util.Pattern</code>
		plus one more:
	</p>
	<table class="dictionary_table">
		<tr>
			<td>i</td>
			<td><code>Pattern.CASE_INSENSITIVE</code></td>
		</tr>
		<tr>
			<td>m</td>
			<td><code>Pattern.MULTILINE</code></td>
		</tr>
		<tr>
			<td>s</td>
			<td><code>Pattern.DOTALL</code></td>
		</tr>
		<tr>
			<td>x</td>
			<td><code>Pattern.COMMENTS</code></td>
		</tr>
		<tr>
			<td>d</td>
			<td><code>Pattern.UNIX_LINES</code></td>
		</tr>
		<tr>
			<td>u</td>
			<td><code>Pattern.UNICODE_CASE</code></td>
		</tr>
		<tr>
			<td>r</td>
			<td>expression is reversible -- if it matches a sequence it will
				also match the reverse of this sequence -- or reversed; so it is
				usable in a lookbehind assertion. In the latter case, where it is
				reversed, <em>it cannot be used except in backwards assertions</em>.
			</td>
		</tr>
	</table>
	<p>
		This last modifier <em>cannot</em> be placed inside the slashes but
		must be appended after.
	</p>
	<h4>Why regular expressions in grammars</h4>
	<p>
		Since a
		<code>dfh.grammar.Grammar</code>
		duplicates almost every capability of a Java regular expression you
		might wonder why these are necessary at all. It is because
		<code>dfh.grammar.Grammar</code>
	<ol>
		<li>lacks anchor constructs -- <code>\b</code> , <code>^</code> ,
			<code>$</code> , <code>\A</code> , <code>\Z</code> and so forth
		</li>
		<li>lacks character classes, which are particularly nice in Java</li>
		<li>lacks modifiers equivalent to <code>Pattern.CASE_INSENSITIVE</code>
			or <code>Pattern.MULTILINE</code>.
		</li>
		<li>If you can make do with the more impoverished pattern
			capturing ability of regular expressions, they're much faster, so the
			more you can rely on them rather than grammars the faster your code
			will be.</li>
		<li>If you have pre-existing regular expressions, it is
			convenient to be able plug them into grammars unchanged.</li>
	</ol>
	</p>
	<h3>Literals</h3>
	<pre>rule1 = <b>'</b>"foo"<b>'</b>
rule2 = <b>"</b>'foo'<b>"</b> </pre>
	<p>String literals are sequences of characters enclosed in double
		or single quotes. Every character in the literal must be identical to
		the corresponding character in the sequence matched against for a
		literal rule to match.</p>
	<h4>Escape sequences</h4>
	<p>
		All the escape sequences that work in Java string literals work in
		<code>dfh.grammar</code>
		string literals.
	</p>
	<h2>External Rule Definition</h2>
	<p>
		You may wish to build grammars compositionally by using one to define
		a rule in another, to plug your own extensions of
		<code>dfh.grammar.Rule</code>
		in, or to build large or variable regular expressions programmatically
		and then plug them into a static grammar. There are two ways to do
		this.
	</p>
	<h3>Pre-loading Rules</h3>
	<p>you may load in a mapping from rule labels to rules in while
		compiling the grammar
	<pre>		Map&lt;String, Rule&gt; map = new HashMap&lt;String, Rule&gt;(1);
		map.put("r", whateverRule);
		String[] rules = {
		//
		"ROOT = ~- &lt;r&gt; 'bar'",//
		};
		Grammar g = new Grammar(rules, map);</pre>
	It is necessary to pre-load rules if you wish to use them in lookbehind
	assertions, as in this example. The compiler needs to confirm that any
	rule in a lookbehind is reversible and it is only able to do this if it
	already has the rules on hand during compilation.
	</p>
	<h3>Deferred Rule Definition</h3>
	<p>If you do not plan to use the rules in lookbehinds you may
		compile a grammar with undefined rules and define these after.
	<pre>		String[] rules = {
		//
		"ROOT = &lt;q&gt; &lt;text&gt; &lt;bar&gt; 1",//
		};
		Grammar g = new Grammar(rules);
		g.defineRule("q", Pattern.compile("[\"']")); // <b>deferred regular expression</b>
		g.defineRule("text", whateverRule);          // <b>deferred arbitrary rule</b>
		g.defineRule("bar","quux");                  // <b>deferred string literal</b>
	</pre>
	As you can see from this example, deferred rule definition is somewhat
	more convenient than pre-loaded rules. For one thing, it is more
	concise and hence easier to read. For another, there are convenience
	methods for defining deferred rules when they are to match literal
	character sequences or regular expressions.
	</p>
	<p>
		Naturally, if you attempt to match a grammar with undefined rules
		against a character sequence a
		<code>dfh.grammar.GrammarException</code>
		will be thrown.
	</p>
	<h2>Conditions</h2>
	<pre>		String[] rules = {
		//
		"ROOT = /\\b\\d++\\b/ <b>(less_than_100)</b>",//
		};
		Grammar g = new Grammar(rules);
		<b>g.defineCondition("less_than_100", new Condition() {
			public boolean passes(Match m, Matcher n, CharSequence s) {
				int i = Integer.parseInt(s.subSequence(m.start(), m.end())
						.toString());
				return i < 100;
			}
		});</b>
		String s = "99 100 1000";
		Matcher m = g.find(s);
		Match n;
		while ((n = m.match()) != null)
			System.out.println(s.substring(n.start(), n.end()));</pre>
	<p>Conditions are perhaps the most powerful feature grammars have
		beyond those they share with regular expressions. These are arbitrary
		tests that can be applied after a rule has matched. The example above
		produces
	<pre class="results">99</pre>
	</p>
	<p>Caution should be taken when using conditions. In particular,
		they should be functional: a condition that matches at a particular
		offset in a character sequence should always match. Do not make
		conditions dependent on unrelated state such as the weather at
		matching time, the phase of the moon, or the contents of a dynamic
		database. To do otherwise would invalidate the results cached when
		matches at this offset are attempted and possibly lead to false
		negatives when matching.</p>
	<p>Also, you may not realize how frequently a condition needs to be
		tested. Matching recursive patterns is exponentially complex. The
		grammar is able to store whether the conditionalized rule ever matches
		at a particular offset but not all the ways it can match. Hence
		conditions are a good way to slow down a match. If you find the
		condition slows down the match unacceptably you may need to remove
		condition testing to a post-processing stage. This has the
		disadvantage that it is less declarative and may require iterating
		over a great many matches in post-processing -- you probably will want
		to iterate over all possible matches, not merely all non-overlapping
		matches. On the other hand, you will most likely need to apply the
		test less often than you would in the midst of matching.</p>
	<h3>Methods on the Condition Object</h3>
	<p>
		A condition object by itself does nothing useful -- it doesn't know
		when it should pass or fail so it always passes. To make such an
		object useful, you must override one of its
		<code>passes</code>
		methods.
	</p>
	<h4>
		<code>passes(Match, Matcher, CharSequence)</code>
	</h4>
	<p>
		This method gives you the most contextual information so it allows you
		to write the most powerful conditions. You can consider any previous
		match and its properties<span class="fn">though not subsequent
			matches; you'll have to use post-match filtering for that</span>. Also, if
		you override one of the other methods there will be a longer call
		chain during condition testing, so overriding this method will give
		you some efficiency gains. However, if you might be dealing with
		backwards lookbehinds you'll need to take care to handle order
		reversal and so forth. If you cna get away with it, it is probably
		best to override one of the methods with a more pared down signature
		so you don't need to worry about such things.
	</p>
	<h4>
		<code>passes(Match, CharSequence)</code>
	</h4>
	<p>This method will give you the entire match tree rooted at this
		match and the character sequence to work with. You still have to
		handle character reversal yourself.</p>
	<h4>
		<code>passes(CharSequence)</code>
	</h4>
	<p>This simplest method is most likely what you want to deal with.
		It gives you just the sequence of characters matched in proper order.</p>
	<h3>Numerical Conditions</h3>
	<p>
		Quite often conditions express some numerical relation. This requires
		parsing the matched character sequence as the right sort of number and
		then applying numerical tests. To facilitated this, there are two
		numerical subclasses of
		<code>dfh.grammar.Condition</code>
		that will do the number parsing for you, leaving you to implement the
		numerical test. These classes are:
	</p>
	<ul>
		<li><code>dfh.grammar.IntegerCondition</code></li>
		<li><code>dfh.grammar.FloatingPointCondition</code></li>
	</ul>
	<h3>Logical Conditions</h3>
	<p>
		Quite often you will want to apply some boolean combination of
		conditions to a match --
		<code>a&nbsp;&amp;&nbsp;b</code>
		or
		<code>a&nbsp;&amp;&nbsp;!(b&nbsp;|&nbsp;c)</code>
		, for example. You may do so, using parentheses for grouping and the
		logical operators
		<code>&amp;</code>
		(&ldquo;and&rdquo;),
		<code>|</code>
		(&ldquo;or&rdquo;), and
		<code>^</code>
		(&ldquo;exclusive or&rdquo;). Blank space is a synonym for
		<code>&amp;</code>
		, so
		<code>a&nbsp;b</code>
		is interpreted identically to
		<code>a&nbsp;&amp&nbsp;b</code>
		. Logical conditions short circuit, so it's best to test your cheap
		conditions before your expensive ones.
	</p>
	<h2>Assertions</h2>
	<p>Assertions are in effect special conditions that may appear
		anywhere in a rule. They do not move the character matching offset but
		will cause the rule or match to fail if some condition is not met.</p>
	<h3>Zero-Width Matches</h3>
	<p>Zero-width matches are rules that test whether the characters
		adjacent to the current offset meet some condition. You may define a
		great many of these with ordinary regular expressions:</p>
	<pre>String[] rules = {
        //
        "  ROOT = &lt;matt&gt; &lt;s&gt; &lt;joe&gt; &lt;s&gt; &lt;is_sue&gt;",//
        "   joe = /\\bjoe\\b/i",//
        "is_sue = /(?=sue)/i",//   <b>looks ahead</b>
        "is_mat = /(?&lt;=matt)/i",// <b>looks behind</b>
        "     s = /\\s++/",//
};</pre>
	<p>The problem with doing this this way, though, is that</p>
	<ol>
		<li>you are limited to terminal rules</li>
		<li>your backwards assertions must be fixed-width</li>
	</ol>
	<p>
		So
		<code>dfh.grammar</code>
		provides its own assertion syntax with which you can define assertions
		which are variable width in either direction.
	</p>
	<h4>Lookaheads</h4>
	<pre>String[] rules = {
        //
        "ROOT = &lt;a&gt; /\\s++/ &lt;b&gt; /\\s++/ &lt;c&gt; /\\s++/ &lt;d&gt;",//
        "   a = <b>~</b>          '1' /\\b\\d++/",//     <b>the number must begin with 1</b>
        "   b = <b>~+</b>         '2' /\\b\\d++/",//     <b>synonym; the '+' here simply means "forward"</b>
        " b_2 = <b>before</b>     '2' /\\b\\d++/",//     <b>or you can use plain English</b>
        "   c = <b>!</b>          '3'     /\\b\\d++/",// <b>the number must not begin with 3</b>
        "   d = <b>!+</b>         '4'     /\\b\\d++/",//
        " d_2 = <b>not before</b> '4' /\\b\\d++/",//     <b>plain English negation</b>
        " d_3 = <b>notbefore</b>  '4' /\\b\\d++/",//
        " d_4 = <b>!before</b>    '4' /\\b\\d++/",//
        " d_5 = <b>! before</b>   '4' /\\b\\d++/",//
};</pre>
	<p>
		The examples above are silly but they serve to illustrate the syntax.
		If you prefer concision there are the single character variant:
		<code>~</code>
		and
		<code>!</code>
		. To these you may a directional suffix,
		<code>+</code>
		, which means &ldquo;before&rdquo;. This is provided to make the
		forward assertion syntax fully parallel to the backwards assertion
		syntax (see below), but may be omitted.
	</p>
	<p>
		If you prefer clarity, you can use a variety of natural language, or
		abbreviated natural language, expressions:
		<code>before</code>
		,
		<code>not before</code>
		, and the variants substituting
		<code>!</code>
		for
		<code>not</code>
		and/or omitting the space.
	</p>
	<p>The rule immediately to the right of the assertion expression is
		that which must either match or fail to match.</p>
	<h4>Lookbehinds</h4>
	<pre>String[] rules = {
        //
        "ROOT = &lt;a&gt; /\\s++/ &lt;b&gt;",//
        "   a = /\\b\\d++/ <b>~-</b>        '1'",// <b>the number must end in 1</b>
        " a_2 = /\\b\\d++/ <b>after</b>     '1'",// <b>plain English version</b>
        "   b = /\\b\\d++/ <b>!-</b>        '2'",// <b>the number must not end in 2</b>
        " b_2 = /\\b\\d++/ <b>not after</b> '2'",// <b>plain English version</b>
        " b_3 = /\\b\\d++/ <b>notafter</b>  '2'",// <b>and other variants</b>
        " b_4 = /\\b\\d++/ <b>! after</b>   '2'",//
        " b_5 = /\\b\\d++/ <b>!after</b>    '2'",//
};</pre>
	<p>
		Lookbehinds are parallel in syntax to lookaheads except that, for
		obvious reasons, there is no single-character variant. The
		single-character directional suffix is
		<code>-</code>
		and the natural language variant of this is
		<code>after</code>
		.
	</p>
	<p>Note that you do not write the rule backwards that they modify.
		The grammar compiler will do this for you. So for example</p>
	<pre>		String[] rules = {
				//
				"ROOT = !- [ &lt;fred&gt; /\\s++/r ] &lt;fred&gt;",//
				"fred = 'fred'",//
		};
		Grammar g = new Grammar(rules);
		String s = "fred fred bob";
		Matcher m = g.find(s);
		Match n;
		while ((n = m.match()) != null)
			System.out.println(n);</pre>
	<p>produces</p>
	<pre class="results">(!-[ &lt;fred&gt; /\s++/r ] &lt;fred&gt;: 0, 4 [(!-[ &lt;fred&gt; /\s++/r ]: 0, 0), ("fred": 0, 4)])</pre>
	<p>
		That is, it only finds the first <i>fred</i>, and the stringification
		of the match keeps the description facing forwards.
	</p>
	<p>
		Note the
		<code>r</code>
		modifier on the regular expression. A regular expression can only be
		used in a backwards assertion if it carries this modifier, which
		simply marks it as reversible. Reversible regular expressions are
		those which only match palindromes. In this case, a block of all the
		same character class will be a palindrome, so it's reversible. This
		powerful restriction on the regular expressions usable in backwards
		assertions doesn't reduce the power of backwards assertions at all
		inasmuch as the rest of the machinery of matching can be provided by
		<code>dfh.grammar</code>
		itself.
	</p>
	<b>how it works</b>
	<p>
		Backwards assertions work by matching against a
		<code>dfh.grammar.ReversedCharSequence</code>
		, a wrapper class that translates character indices between the base
		and reversed sequences. So character indices count back from the end
		and index 0 refers to the last character. To this reversed character
		sequence it applies a rule identical to the one defined in your
		grammar but with all sequences reversed, so
		<code>'cat'</code>
		covertly becomes
		<code>'tac'</code>
		. This reversal of the sequences occurs at compilation time and it
		works on a copy of the reversed rule tree, so these same rules can be
		applied in a forward direction elsewhere. Regular expressions, because
		of their branching, back references, directional assertions, and so
		forth, are non-trivial to reverse. Also, one could plug in quite vast
		regular expressions which would take some time to reverse during
		compilation. Furthermore, backreferences make some regular expressions
		virtually impossible to handle by reversing the sequence.
	</p>
	<p>
		The
		<code>r</code>
		modifier on a regular expression marks it as reversible or reversed --
		already written to be used on a reversed sequence. Only palindromic
		regular expressions may be used both inside and outside backwards
		assertions.
	</p>
	<p>Backtracking barriers may produce confusing results if used in a
		backwards assertion. Consider the rules</p>
	<pre>ROOT = ~- &lt;a&gt; 'bar'
   a = 'b'+ : 'bc'</pre>
	<p>
		Looking at rule
		<code>&lt;a&gt;</code>
		it appears that it will always fail to match. First it matches a
		sequence of one or more <i>b</i>s. Then it puts up a barrier to any
		backtracking. Then it attempts to match another <i>b</i>. But it
		already matched all the <i>b</i>s it could find, so it must fail! But
		matching from right to left, as the backwards assertion does, means it
		can grab a <i>b</i> before hitting the barrier. In fact, in this case
		the grammar will match <i>bbcbar</i>.
	</p>
	<h3>Backtracking Barriers</h3>
	A backtracking barrier is a sort of meta-assertion. It says, "the
	matching engine will not have to revisit this decision or anything that
	precedes it." It serves a function similar to the
	<code>(?&gt;&nbsp;...&nbsp;)</code>
	in Perl-compatible regular expressions or possessive quantification. It
	makes matching more tractable by eliminating at one stroke some number
	of permutations in the matching engine's search space.
	<h4>:</h4>
	The single-colon barrier indicates that the rule containing it fails if
	it cannot complete the match after the the barrier without revisiting
	decisions before the barrier. If you know that the first few elements
	in a sequence will match only one way if at all, you can follow them
	with the single-colon barrier.
	<h4>::</h4>
	The double-colon barrier indicates that if the portion of the rule
	after the barrier fails to match then the entire grammar fails to match
	at the current offset in the character sequence.
	<h2>Named Captures</h2>
	<pre>&lt;ROOT&gt; = [<b>{a}</b>'a']++
&lt;ROOT&gt; = [<b>{foo}</b> 'a' /\\s++/ 'b']++ [<b>{bar}</b> 'c'] [<b>{baz,quux}</b> 'd' | 'e']</pre>
	<p>
		Some regular expression engines, such as those of Python, Perl, and
		the PCRE library, provide a syntax for naming captured groups. It
		began with Python, where the syntax was
		<code>(?P&lt;name&gt;pattern)</code>
		. This construction assigns a name to whatever
		<code>pattern</code>
		matches, so later one can fetch it for whatever purpose. Other
		languages then adopted similar syntax for this purpose. Perl, for
		instance, provides
		<code>/(?&lt;name&gt;pattern)/</code>
		. Well, for
		<code>dfh.grammar</code>
		I preferred to use the angle brackets, as in BNF, to label rules, so
		you can assign a label to a group in
		<code>dfh.grammar</code>
		using curly brackets instead, as illustrated above.
	</p>
	<p>
		Unlike these various regular expression engines,
		<code>dfh.grammar</code>
		always captures and returns the entire match tree, so all the matches
		are there regardless of whether you've named them or bracketed them.
		The names merely serve to facilitate finding the bits matched by
		particular rules. Furthermore, every named rule always tags its match
		with its name. The curly bracket notation is chiefly useful for what
		would otherwise be anonymous rules. Also, as illustrated in the second
		example above, you may provide more than one name inside the curly
		brackets -- names have the same restrictions as rule labels; the name
		separator inside the brackets is the comma. This allows you to
		multiply categorize matches -- both dates and numbers, say.
	</p>
	<h2>Options</h2>
	<pre>Matcher m = g.find(s);                                               // <b>use all defaults</b>
...
m = g.find(s, new Options().allowOverlap(true).longestMatch(false)); // <b>change two parameters</b>
...
Options opt = new Options().allowOverlap(true).longestMatch(false);  // <b>options are reusable</b>
m = g.find(s2, opt);
...
m = g.find(s3, opt);</pre>
	<p>
		With
		<code>java.regex.Matcher</code>
		matching, one can modify the matching altering various properties of
		the matcher object separately. With
		<code>dfh.grammar</code>
		matching one must pass all the desired options in as a collection when
		creating the matcher. This improves efficiency and ensures the
		immutability of its state aside from its position in the sequence of
		matches over which it is iterating. The parameter collection is an
		instance of
		<code>dfh.grammar.Options</code>
		. Among other things it specifies which should be regarded as the
		first and last characters in the sub-sequence to match against,
		whether overlapping matches should be considered, and whether
		debugging output should be produced.
	</p>
	<h3>start</h3>
	<pre>Options opt = new Options().start(10); // <b>default: 0</b>
System.out.println(opt.start());       // 10</pre>
	<p>If you wish the match to begin at some offset other than 0 in
		the character sequence, set the start. As with regular expressions,
		this will not affect such things as word boundary matching. If the
		string is "abc", there is no word boundary at offset 1 even if this is
		where you start matching.</p>
	<h3>end</h3>
	<pre>Options opt = new Options().end(10); // <b>default: length of sequence</b>
System.out.println(opt.end());       // 10</pre>
	<p>
		<code>end</code>
		is the counterpart of
		<code>start</code>
		: if you do not wish any matches to include indices beyond a
		particular offset, you must send the
		<code>end</code>
		.
	</p>
	<h3>allow overlap</h3>
	<pre>Options opt = new Options().allowOverlap(true); // <b>default: false</b>
System.out.println(opt.allowOverlap());         // true</pre>
	<p>
		By default a grammar will only return one match per offset tested
		against and no two matches returned will contain the same character.
		Suppose, however, that you wish to see all ways a grammar can match a
		string (possibly a very large number!). In this case, you set
		<code>allowOverlap</code>
		to
		<code>true</code>
		.
	</p>
	<h3>keep rightmost match</h3>
	<pre>Options opt = new Options().keepRightmost(true); // <b>default: false</b>
System.out.println(opt.keepRightmost());         // true</pre>
	<p>
		If a match fails you might still want to know, for the sake of
		debugging or error message generation, how far it got before it
		failed. This is what
		<code>keepRightmost</code>
		does for you. Since recording rightmost matches incurs some overhead,
		the default value of this option is
		<code>false</code>
		.
	</p>
	<h3>longest match</h3>
	<pre>Options opt = new Options().longestMatch(true); // <b>default: true</b>
System.out.println(opt.longestMatch());         // true</pre>
	<p>Suppose your grammar contains the alternation</p>
	<pre>foo = 'cat' | 'cat dog'</pre>
	<p>
		Because <i>cat</i> is listed first, the first match returned when a
		find is done against the string <i>camel cat dog fish</i> will be <i>cat</i>
		even though <i>cat dog</i> will also match at the same offset. If you
		are not allowing overlapping matches (see above), you will never see
		the <i>cat dog</i> match. If this is not what you want, set
		<code>longestMatch</code>
		to
		<code>true</code>
		. This will cause the matcher to iterate over all possible matches at
		a given offset, retaining only those of maximum length. If you allow
		overlapping matches, the matcher will return the matches in the order
		of discovery. Otherwise, it will return the first maximum length match
		found.
	</p>
	<p>
		In fact, in my experience I find that I usually want only the longest
		matches and receiving just the first match produces unexpected
		results. The default value of
		<code>longestMatch</code>
		is
		<code>true</code>
		. You have to turn longest matching <em>off</em>, not on.
	</p>
	<h3>match all</h3>
	<pre>Options opt = new Options().matchAll(true); // <b>no default</b>
System.out.println(opt.matchAll());         // true</pre>
	<p>
		The
		<code>matchAll</code>
		option is just a shortcut for setting
		<code>longestMatch</code>
		to
		<code>false</code>
		and
		<code>allowOverlap</code>
		to
		<code>true</code>
		with just one boolean.
	</p>
	<h3>maximum recursion depth</h3>
	<pre>Options opt = new Options().maxRecursionDepth(10); // <b>default: 3</b>
System.out.println(opt.maxRecursionDepth());       // 10</pre>
	<p>
		Recursion and
		<code>dfh.grammar</code>
		's top-down matching are an uneasy mix. Instead of looking at a
		character and figuring out what rules it could match, the grammar
		constructs hypothetical match trees and sees whether they fit the
		underlying sequence. Or rather, it constructs the left branches of
		trees. If it can match the leftmost leaf of the tree, it tries adding
		the next branch. This works fine until you have a recursive grammar
		that allows the possibility of infinite left-branching, something like
	</p>
	<pre>foo = &lt;foo&gt; '0' | '1'</pre>
	<p>
		This grammar is a silly recursive equivalent of
		<code>/10++/</code>
		. Because of the way
		<code>dfh.grammar</code>
		tests alternates -- first alternate first -- it will attempt first to
		construct an infinitely deep left-branching tree, never actually
		trying the
		<code>'1'</code>
		alternate and beginning matching. In this case the solution would be
		to write a less silly grammar, but sometimes you simply have to write
		a left-branching rule. To cope with this situation
		<code>dfh.grammar</code>
		has a maximum branching depth. When the grammar is compiled, it checks
		to see whether there are any problematic cycles of this sort. If it
		finds left-branching recursion, every time it picks an alternate <span
			class="fn">This problem can arise even if the recursive
			alternate isn't first. Suppose, for example, that the first <code>n</code>
			alternates never match and the <code>n + 1</code> alternate is
			recursive.
		</span> in the problematic rule it first checks to see whether it's in a
		repeating loop. If it finds that it is, it increments the recursion
		count. If it finds that it cannot proceed without incrementing the
		count past the maximum recursion depth limit, it abandons the
		alternate and tries the next.
	</p>
	<h3>study</h3>
	<pre>Options opt = new Options().study(false); // <b>default: true</b>
System.out.println(opt.study());          // false</pre>
	<p>
		One way to accelerate matching is to &ldquo;study&rdquo; the character
		sequence. Studying consists of finding all the positions at which
		terminal rules match. This can be done with quick string indexation
		methods and such and it culls the number of offsets that can even be
		attempted. However, it is generally only useful if one is using the
		<code>find</code>
		method for matching. The
		<code>matches</code>
		and
		<code>lookingAt</code>
		methods both consider only a single offset, so most of the work done
		studying is wasted. If you call
		<code>find</code>
		without any options, the sequence will be studied. Likewise, if you
		call the other two without specifying any options the sequence will
		not be studied.
	</p>
	<h3>fat memory</h3>
	<pre>Options opt = new Options().fatMemory(true); // <b>default: false</b>
System.out.println(opt.fatMemory());         // true</pre>
	<p>
		Another way to accelerating matching is to use a quicker match caching
		mechanism that wastes more memory. If you do nothing, the grammar will
		choose its caching mechanism based on the length of the sequence being
		matched against. If it is long (see below), a hash map based cache
		will be used. Otherwise an array-based cache is used. If you set
		<code>fatMemory</code>
		to true, the array-based cache will be used regardless of the sequence
		length.
	</p>
	<h3>lean memory</h3>
	<pre>Options opt = new Options().leanMemory(true); // <b>default: false</b>
System.out.println(opt.leanMemory());         // true</pre>
	<p>If you are matching against a particularly long character
		sequence, or you have a particularly complicated grammar, you may be
		concerned that you will exhaust the heap. You can reduce memory use by
		choosing a lean match cache. Whereas the fatter caches are array and
		hash based, the lean cache is a tree map. The array cache allocates
		storage space for every offset immediately. The hash cache doubles its
		memory allotment periodically as it fills up. The tree cache only
		grabs additional memory gradually as it fills up.</p>
	<h3>long string length</h3>
	<pre>Options opt = new Options().longStringLength(10000); // <b>default: 100000</b>
System.out.println(opt.longStringLength());          // 10000</pre>
	<p>
		If you don't set either
		<code>fatMemory</code>
		or
		<code>leanMemory</code>
		to true, the match cache will be chosen based on the length of the
		sequence matched against. Specifically, if the length is less than
		<code>longStringLength</code>
		, an array cache will be used. Otherwise it will be a hash-based
		cache.
	</p>
	<h3>log</h3>
	<pre>Options opt = new Options().log(System.err); // <b>default: null</b>
opt.trace().println(10);                     // 10</pre>
	<p>
		The
		<code>log</code>
		option is a
		<code>java.io.PrintStream</code>
		to which log messages will be printed if it isset to a non-null value.
		In fact, setting the
		<code>log</code>
		to some print stream causes a boolean debug option to be set to
		<code>true</code>
		, which causes a number of debuggign code blocks to be called in the
		course of matching. Logging a match thus incurs a good bit of
		overhead, but due to the exponential complexity of matching it is
		often the best way to debug a grammar.
	</p>
</body>
</html>
