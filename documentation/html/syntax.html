<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>dfh.grammar.Grammar</title>
<link href="grammar.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="headers.json"></script>
<script type="text/javascript" src="scripts/pageutils.js"></script>
</head>
<body onLoad="prepare('syntax', 'dfh.grammar')">
	<h1>Syntax</h1>
	<div>
		A grammar is specified via a formalism similar to a <a
			href="http://en.wikipedia.org/wiki/Backus-Naur_form">Backus-Naur
			Form</a> grammar, though the point of grammars is not to parse BNF
		grammars or express <a
			href="http://en.wikipedia.org/wiki/Context-free_grammar">context-free
			grammars</a> but to create useful character sequence matchers.
		Consequenty, no claims are made as to the purity of grammars as CFGs
		or whatever other theoretical construct. Basically, a grammar is a
		collection of matching rules, where every rule specifies a pattern of
		terminal expressions -- character sequences -- or non-terminal rules.
	</div>
	<span id="toc"></span>
	<h2>General Rules</h2>
	<div>
		Here is the grammar understood by
		<code>dfh.grammar</code>
		expressed in its own formalism:
	</div>
	<pre>                &lt;ROOT&gt; = &lt;grammar&gt;

             &lt;grammar&gt; = &lt;padding&gt;* &lt;root&gt; &lt;post_root&gt;*
           &lt;post_root&gt; = [ &lt;non_rule&gt; | &lt;rule&gt; ] &lt;nl&gt;
                &lt;root&gt; = "&lt;ROOT&gt;" &lt;right_part&gt;
                &lt;rule&gt; = "&lt;" &lt;identifier&gt; "&gt;" &lt;right_part&gt;
          &lt;right_part&gt; = &lt;equals&gt; &lt;rule_body&gt;
           &lt;rule_body&gt; = &lt;main_part&gt; [ &lt;space&gt;? &lt;condition&gt; ]? [ &lt;space&gt;? &lt;comment&gt; ]?
           &lt;main_part&gt; = &lt;regex&gt; | &lt;element&gt;
                 &lt;alt&gt; = &lt;element&gt; [ &lt;space&gt;? "|" &lt;element&gt; &lt;space&gt;? ]++
           &lt;assertion&gt; = &lt;backtracking_barrier&gt; | &lt;forward_assertion&gt; | &lt;backward_assertion&gt;
  &lt;backward_assertion&gt; = &lt;assertion_marker&gt; "-" &lt;space&gt;? &lt;delimited_element&gt;
     &lt;complex_element&gt; = &lt;alt&gt; | &lt;seq&gt;
   &lt;delimited_element&gt; = &lt;simple_element&gt; | "[" &lt;complex_element&gt; "]"
             &lt;element&gt; = "[" &lt;element&gt; "]" | &lt;modifiable_element&gt; | &lt;assertion&gt;
   &lt;forward_assertion&gt; = &lt;assertion_marker&gt; "+"? &lt;space&gt;? &lt;delimited_element&gt;
  &lt;modifiable_element&gt; = &lt;simple_element&gt; | &lt;complex_element&gt;
                 &lt;rep&gt; = &lt;delimited_element&gt; &lt;repetition&gt;
                 &lt;seq&gt; = &lt;element&gt; [ &lt;space&gt;? [ &lt;element&gt; | &lt;d&gt;++ ] ]++
      &lt;simple_element&gt; = &lt;id&gt; | &lt;literal&gt; | &lt;rep&gt;
             &lt;literal&gt; = &lt;single_quote&gt; | &lt;double_quote&gt;
             &lt;padding&gt; = &lt;non_rule&gt; &lt;nl&gt;
           &lt;condition&gt; = "(" &lt;identifier&gt; ")"
        &lt;double_quote&gt; = '"' [ &lt;ndq&gt; | &lt;escaped&gt; ]++ '"'
                  &lt;id&gt; = "&lt;" &lt;identifier&gt; "&gt;"
            &lt;non_rule&gt; = &lt;space&gt;? &lt;comment&gt;?
          &lt;repetition&gt; = [ &lt;simple_rep&gt; | &lt;delimited_rep&gt; ] [ "?" | "+" ]?
        &lt;single_quote&gt; = "'" [ &lt;nsq&gt; | &lt;escaped&gt; ]++ "'"
    &lt;assertion_marker&gt; = "~" | "!"
       &lt;backreference&gt; = &lt;d&gt;++
&lt;backtracking_barrier&gt; = ":"{1,2}
             &lt;comment&gt; = "#" &lt;dot&gt;*
       &lt;delimited_rep&gt; = "{" [ &lt;d&gt;++ | "," &lt;d&gt;++ | &lt;d&gt;++ "," | &lt;d&gt;++ "," &lt;d&gt;++ ] "}"
              &lt;equals&gt; = &lt;space&gt;? "=" &lt;space&gt;?
             &lt;escaped&gt; = "\\\\" &lt;dot&gt;
          &lt;identifier&gt; = &lt;w&gt;++
               &lt;regex&gt; = "/" &lt;dot&gt;++ "/" &lt;regex_suffix&gt;?
          &lt;simple_rep&gt; = "*" | "?" | "+"
                   &lt;d&gt; = /\d/
                 &lt;dot&gt; = /./
                 &lt;ndq&gt; = /[^"\\]/
                  &lt;nl&gt; = /\n/
                 &lt;nsq&gt; = /[^'\\]/
        &lt;regex_suffix&gt; = /[rimsdux]++/
               &lt;space&gt; = /[\s&amp;&amp;[^\n]]++/
                   &lt;w&gt; = /\w/</pre>
	<p>Basically, a grammar expects a set of rules, each of which may
		define a terminal character pattern or a set of constituent rules. The
		matching is top-down: the grammar attempts to match a master rule,
		which generally requires matching constituent rules.</p>
	<h3>Rule</h3>
	<p>
		A rule is composed of two parts: a label and a body. The label must
		match the pattern
		<code>/&lt;\w+&gt;|\w+/</code>
		, that is, a sequence of word characters, optionally surrounded by
		angle brackets. The label is separated from the body by the
		<code>=</code>
		character. The rule body consists of a list of constituent rules and
		may optionally end in a post-match condition and/or comment. If a
		constituent rule is a labeled rule, it is referred to by its label
		inside angle brackets. Some examples:
	<pre>&lt;r1&gt; = 'a'
 r2  = &lt;r1&gt; 'b'
&lt;r3&gt; = /\b regex \b/ix
&lt;r4&gt; = "alt" | "ernation" # a comment
&lt;r5&gt; = 'c' (condition)</pre>
	</p>
	<p>Except in quoting expressions &mdash; a sequence inside a pair
		of angle brackets, single quotes, double quotes, or forward slashes
		&mdash; whitespace is ignored, so you can format your rules however
		you wish; but every rule definition must fit on a single line.</p>
	<h3>Root</h3>
	<pre>&lt;ROOT&gt; = 'some' 'rule'</pre>
	<p>
		The root rule is a rule like any other: a label followed by a
		definition. It always has the label
		<code>&lt;ROOT&gt;</code>
		, however, and it is always the rule the grammar first tries to match.
		If the grammar can match the root rule against the character sequence,
		then the grammar matches; it not, it doesn't.
	</p>
	<p>It is convenient to list the root rule first in the grammar but
		this is not required. It is identified not by its position but by its
		label.</p>
	<h3>Comments</h3>
	<p>
		The grammar parser ignores blank lines. The comment character is
		<code>#</code>
		. If this character appears outside of some quoting construction
		&mdash; double or single quotes or the forward slashes bracketing a
		regular expression &mdash; everything after it is ignored.
	<pre>
		
# this and the previous line are ignored
rule = 'a' # and this is ignored as well</pre>
	</p>
	<h2>Usual Bits</h2>
	<h3>Sequence</h3>
	<pre>rule = 'a' 'b'</pre>
	<h3>Alternation</h3>
	<pre>rule = 'a' <b>|</b> 'b'</pre>
	<h3>Repetition</h3>
	<pre>rule = 'a'<b>*</b> 'b'<b>?</b> 'c'<b>+</b> 'd'<b>*?</b> 'e'<b>??</b> 'f'<b>+?</b> 'g'<b>*+</b> 'h'<b>?+</b> 'i'<b>++</b> 'j'<b>{2}</b> 'k'<b>{1,5}?</b> # etc</pre>
	<h3>Group</h3>
	<pre>rule = <b>[</b> 'a' | 'b' <b>]</b>{3,}+ # the "{3,}+" is just to give the group syntax a purpose</pre>
	<h3>Back Reference</h3>
	<pre>rule = /["'"]/ /\w++/ <b>1</b></pre>
	<h2>Terminal Rules</h2>
	<p>
		Terminals rules have no constituent rules. They match against a
		character sequence at some offset or they don't. If a grammar has no
		terminal rules, it never makes contact with the underlying character
		sequence and hence can never match.<span class="fn">This state
			of affairs will be found during compilation and a <code>dfh.grammar.GrammarException</code>
			will be thrown, aborting the program. The exception will carry an
			explanatory message such as "cycle found in rules: &lt;b&gt;,
			&lt;a&gt;".
		</span>
	</p>
	<p>During matching, the matcher will cache some information about
		attempted matches by various rules at various offsets in the character
		sequence. For non-terminal rules all that is cached is the success or
		failure of the match. This is to prevent the cache from consuming too
		much memory &mdash; a particular non-terminal rule can potentially
		match exponentially many ways at a given offset. Because the number of
		possible terminal matches is linear in the length of the sequence, the
		whole match object is stored for terminal matches, accelerating the
		match process.</p>
	<h3>Regular Expressions</h3>
	<pre>rule = <b>/</b>^ foo \b<b>/imx</b></pre>
	<p>
		Any Java regular expression (aside from multi-line expressions with
		the
		<code>x</code>
		modifier) can be placed inside forward slashes and used in a rule.
		Modifiers can either be included inside the slashes like so
	<pre>rule = /(?i:foo)/</pre>
	or appended after the last slash as in Perl.
	<pre>rule = /foo/i</pre>
	</p>
	<h4>Regex modifiers</h4>
	<p>
		Regular expressions can take all the modifiers understood by
		<code>java.util.Pattern</code>
		plus one more:
	</p>
	<table class="dictionary_table">
		<tr>
			<td>i</td>
			<td><code>Pattern.CASE_INSENSITIVE</code></td>
		</tr>
		<tr>
			<td>m</td>
			<td><code>Pattern.MULTILINE</code></td>
		</tr>
		<tr>
			<td>s</td>
			<td><code>Pattern.DOTALL</code></td>
		</tr>
		<tr>
			<td>x</td>
			<td><code>Pattern.COMMENTS</code></td>
		</tr>
		<tr>
			<td>d</td>
			<td><code>Pattern.UNIX_LINES</code></td>
		</tr>
		<tr>
			<td>u</td>
			<td><code>Pattern.UNICODE_CASE</code></td>
		</tr>
		<tr>
			<td>r</td>
			<td>expression is reversible &mdash; if it matches a sequence it
				will also match the reverse of this sequence &mdash; so it is usable
				in a lookbehind assertion</td>
		</tr>
	</table>
	<p>
		This last modifier <em>cannot</em> be placed inside the slashes but
		must be appended after.
	</p>
	<h4>Why regular expressions in grammars</h4>
	<p>
		Since a
		<code>dfh.grammar.Grammar</code>
		duplicates almost every capability of a Java regular expression you
		might wonder why these are necessary at all. It is because
		<code>dfh.grammar.Grammar</code>
	<ol>
		<li>lacks the semantics of anchors &mdash; <code>\b</code> , <code>^</code>
			, <code>$</code> , <code>\A</code> , <code>\Z</code> and so forth
		</li>
		<li>lacks character class semantics, which are particularly nice
			in Java</li>
		<li>lacks modifiers equivalent to <code>Pattern.CASE_INSENSITIVE</code>
			or <code>Pattern.MULTILINE</code>.
		</li>
		<li>If you can make do with the more impoverished semantics and
			pattern capturing ability of regular expressions, they're much
			faster, so the more you can rely on them rather than grammars the
			faster your code will be.</li>
		<li>If you have pre-existing regular expressions, it is
			convenient to be able plug them into grammars unchanged.</li>
	</ol>
	</p>
	<h3>Literals</h3>
	<pre>rule1 = <b>'</b>"foo"<b>'</b>
rule2 = <b>"</b>'foo'<b>"</b> </pre>
	<p>String literals are sequences of characters enclosed in double
		or single quotes. Every character in the literal must be identical to
		the corresponding character in the sequence matched against for a
		literal rule to match.</p>
	<h4>Escape sequences</h4>
	<p>
		All the escape sequences that work in Java string literals work in
		<code>dfh.grammar</code>
		string literals.
	</p>
	<h2>Deferred Rule Definition</h2>
	<h2>Conditions</h2>
	<h2>Assertions</h2>
	<h3>Zero-Width Matches</h3>
	<h3>Backtracking Barriers</h3>
	A backtracking barrier is a sort of meta-assertion. It says, "the
	matching engine will not have to revisit this decision or anything that
	precedes it." It serves a function similar to the
	<code>(?&gt;&nbsp;...&nbsp;)</code>
	in Perl-compatible regular expressions or possessive quantification. It
	makes matching more tractable by eliminating at one stroke some number
	of permutations in the matching engine's search space.'
	<h4>:</h4>
	The single-colon barrier indicates that the rule containing it fails if
	it cannot complete the match after the the barrier without revisiting
	decisions before the barrier. If you know that the first few elements
	in a sequence will match only one way if at all, you can follow them
	with the single-colon barrier.
	<h4>::</h4>
	The double-colon barrier indicates that if the portion of the rule
	after the barrier fails to match then the entire grammar fails to match
	at the current offset in the character sequence.
	<h2>Options</h2>
	With
	<code>java.regex.Matcher</code>
	matching, one can modify the matching altering various properties of
	the matcher object separately. With
	<code>dfh.grammar</code>
	matching one must pass all the desired options in as a collection when
	creating the matcher. This improves efficiency and ensures the
	immutability of its state aside from its position in the sequence of
	matches over which it is iterating. The parameter collection is an
	instance of
	<code>dfh.grammar.Options</code>
	. Among other things is specifies which should be regarded as the first
	and last characters in the sub-sequence to match against, whether
	overlapping matches should be considered, and whether debugging output
	should be produced.
</body>
</html>