<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>dfh.grammar.Grammar</title>
<link href="grammar.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="headers.json"></script>
<script type="text/javascript" src="scripts/pageutils.js"></script>
</head>
<body onLoad="dfh.prepare('syntax', 'dfh.grammar')">
	<h1>Syntax</h1>
	<div>
		A grammar is specified via a formalism similar to a <a
			href="http://en.wikipedia.org/wiki/Backus-Naur_form">Backus-Naur
			Form</a> grammar, though the point of grammars is not to parse BNF
		grammars or express <a
			href="http://en.wikipedia.org/wiki/Context-free_grammar">context-free
			grammars</a> but to create useful character sequence matchers.
		Consequenty, no claims are made as to the purity of grammars as CFGs
		or whatever other theoretical construct. Basically, a grammar is a
		collection of matching rules, where every rule specifies a pattern of
		terminal expressions -- character sequences -- or non-terminal rules.
	</div>
	<span id="toc"></span>
	<h2>General Rules</h2>
	<div>
		Here is the grammar understood by
		<code>dfh.grammar</code>
		expressed in its own formalism:
	</div>
	<pre>                &lt;ROOT&gt; = &lt;grammar&gt;

             &lt;grammar&gt; = &lt;padding&gt;* &lt;root&gt; &lt;post_root&gt;*
           &lt;post_root&gt; = [ &lt;non_rule&gt; | &lt;rule&gt; ] &lt;nl&gt;
                &lt;root&gt; = "&lt;ROOT&gt;" &lt;right_part&gt;
                &lt;rule&gt; = "&lt;" &lt;identifier&gt; "&gt;" &lt;right_part&gt;
          &lt;right_part&gt; = &lt;equals&gt; &lt;rule_body&gt;
           &lt;rule_body&gt; = &lt;main_part&gt; [ &lt;space&gt;? &lt;condition&gt; ]? [ &lt;space&gt;? &lt;comment&gt; ]?
           &lt;main_part&gt; = &lt;regex&gt; | &lt;element&gt;
                 &lt;alt&gt; = &lt;element&gt; [ &lt;space&gt;? "|" &lt;element&gt; &lt;space&gt;? ]++
           &lt;assertion&gt; = &lt;backtracking_barrier&gt; | &lt;forward_assertion&gt; | &lt;backward_assertion&gt;
  &lt;backward_assertion&gt; = &lt;assertion_marker&gt; "-" &lt;space&gt;? &lt;delimited_element&gt;
     &lt;complex_element&gt; = &lt;alt&gt; | &lt;seq&gt;
   &lt;delimited_element&gt; = &lt;simple_element&gt; | "[" &lt;complex_element&gt; "]"
             &lt;element&gt; = "[" &lt;element&gt; "]" | &lt;modifiable_element&gt; | &lt;assertion&gt;
   &lt;forward_assertion&gt; = &lt;assertion_marker&gt; "+"? &lt;space&gt;? &lt;delimited_element&gt;
  &lt;modifiable_element&gt; = &lt;simple_element&gt; | &lt;complex_element&gt;
                 &lt;rep&gt; = &lt;delimited_element&gt; &lt;repetition&gt;
                 &lt;seq&gt; = &lt;element&gt; [ &lt;space&gt;? [ &lt;element&gt; | &lt;d&gt;++ ] ]++
      &lt;simple_element&gt; = &lt;id&gt; | &lt;literal&gt; | &lt;rep&gt;
             &lt;literal&gt; = &lt;single_quote&gt; | &lt;double_quote&gt;
             &lt;padding&gt; = &lt;non_rule&gt; &lt;nl&gt;
           &lt;condition&gt; = "(" &lt;identifier&gt; ")"
        &lt;double_quote&gt; = '"' [ &lt;ndq&gt; | &lt;escaped&gt; ]++ '"'
                  &lt;id&gt; = "&lt;" &lt;identifier&gt; "&gt;"
            &lt;non_rule&gt; = &lt;space&gt;? &lt;comment&gt;?
          &lt;repetition&gt; = [ &lt;simple_rep&gt; | &lt;delimited_rep&gt; ] [ "?" | "+" ]?
        &lt;single_quote&gt; = "'" [ &lt;nsq&gt; | &lt;escaped&gt; ]++ "'"
    &lt;assertion_marker&gt; = "~" | "!"
       &lt;backreference&gt; = &lt;d&gt;++
&lt;backtracking_barrier&gt; = ":"{1,2}
             &lt;comment&gt; = "#" &lt;dot&gt;*
       &lt;delimited_rep&gt; = "{" [ &lt;d&gt;++ | "," &lt;d&gt;++ | &lt;d&gt;++ "," | &lt;d&gt;++ "," &lt;d&gt;++ ] "}"
              &lt;equals&gt; = &lt;space&gt;? "=" &lt;space&gt;?
             &lt;escaped&gt; = "\\\\" &lt;dot&gt;
          &lt;identifier&gt; = &lt;w&gt;++
               &lt;regex&gt; = "/" &lt;dot&gt;++ "/" &lt;regex_suffix&gt;?
          &lt;simple_rep&gt; = "*" | "?" | "+"
                   &lt;d&gt; = /\d/
                 &lt;dot&gt; = /./
                 &lt;ndq&gt; = /[^"\\]/
                  &lt;nl&gt; = /\n/
                 &lt;nsq&gt; = /[^'\\]/
        &lt;regex_suffix&gt; = /[rimsdux]++/
               &lt;space&gt; = /[\s&amp;&amp;[^\n]]++/
                   &lt;w&gt; = /\w/</pre>
	<p>Basically, a grammar expects a set of rules, each of which may
		define a terminal character pattern or a set of constituent rules. The
		matching is top-down: the grammar attempts to match a master rule,
		which generally requires matching constituent rules.</p>
	<h3>Rule</h3>
	<p>
		A rule is composed of two parts: a label and a body. The label must
		match the pattern
		<code>/&lt;\w+&gt;|\w+/</code>
		, that is, a sequence of word characters, optionally surrounded by
		angle brackets. The label is separated from the body by the
		<code>=</code>
		character. The rule body consists of a list of constituent rules and
		may optionally end in a post-match condition and/or comment. If a
		constituent rule is a labeled rule, it is referred to by its label
		inside angle brackets. Some examples:
	<pre>&lt;r1&gt; = 'a'
 r2  = &lt;r1&gt; 'b'
&lt;r3&gt; = /\b regex \b/ix
&lt;r4&gt; = "alt" | "ernation" # a comment
&lt;r5&gt; = 'c' (condition)</pre>
	</p>
	<p>Except in quoting expressions -- a sequence inside a pair of
		angle brackets, single quotes, double quotes, or forward slashes --
		whitespace is ignored, so you can format your rules however you wish;
		but every rule definition must fit on a single line.</p>
	<h3>Root</h3>
	<pre>&lt;ROOT&gt; = 'some' 'rule'</pre>
	<p>
		The root rule is a rule like any other: a label followed by a
		definition. It always has the label
		<code>&lt;ROOT&gt;</code>
		, however, and it is always the rule the grammar first tries to match.
		If the grammar can match the root rule against the character sequence,
		then the grammar matches; it not, it doesn't.
	</p>
	<p>It is convenient to list the root rule first in the grammar but
		this is not required. It is identified not by its position but by its
		label.</p>
	<h3>Comments</h3>
	<p>
		The grammar parser ignores blank lines. The comment character is
		<code>#</code>
		. If this character appears outside of some quoting construction --
		double or single quotes or the forward slashes bracketing a regular
		expression -- everything after it is ignored.
	<pre>
		
# this and the previous line are ignored
rule = 'a' # and this is ignored as well</pre>
	</p>
	<h2>Usual Bits</h2>
	<h3>Sequence</h3>
	<pre>rule = 'a' 'b'</pre>
	<p>As in Java regular expressions.</p>
	<h3>Alternation</h3>
	<pre>rule = 'a' <b>|</b> 'b'</pre>
	<p>As in Java regular expressions.</p>
	<h3>Repetition</h3>
	<pre>rule = 'a'<b>*</b> 'b'<b>?</b> 'c'<b>+</b> 'd'<b>*?</b> 'e'<b>??</b> 'f'<b>+?</b> 'g'<b>*+</b> 'h'<b>?+</b> 'i'<b>++</b> 'j'<b>{2}</b> 'k'<b>{1,5}?</b> # etc</pre>
	<p>
		As in Java regular expressions. The curly bracket notation accepts
		<code>
			{,<i>n</i>}
		</code>
		as a synonym for
		<code>
			{0,<i>n</i>}
		</code>
		.
	</p>
	<h3>Group</h3>
	<pre>rule1 = <b>[</b> 'a' | 'b' <b>]</b>{3,}+ # the "{3,}+" is just to give the group syntax a purpose
rule2 = <b>[</b> 'a'* 'b' <b>]{1}+</b>   # a non-backtracking group</pre>
	<p>
		Unlike in Java and Perl 5, but following the convention of Perl 6, the
		grouping brackets are not
		<code>()</code>
		but
		<code>[]</code>
		. Round brackets are reserved for conditions. Note that
		<code>dfh.grammar</code>
		lacks its own character class syntax -- for that you must use Java
		native regular expressions. Also, there are no subvarieties of
		grouping expressions as there are in Java and Perl. Every group is a
		capturing group inasmuch as every match retains the entire match tree.
		There are (currently) no in-line match modifiers; for this you must
		rely on native regular expressions. For the equivalent of
		<code>(?&gt;...)</code>
		you must use the repetition suffix
		<code>{1}+</code>
		. Perhaps at some future date I will add a shorthand notation for
		this.
	</p>
	<h3>Back Reference</h3>
	<pre>rule = /["'"]/ /\w++/ <b>1</b> </pre>
	<p>
		Note: no group construct is required but the index is relative to the
		elements <em>of the same rule</em>. This is due to the complexity of
		interpreting backreferences in recursive patterns. If you need
		something more powerful than this you can do it with conditions,
		though this will cost you efficiency.
	</p>
	<h2>Terminal Rules</h2>
	<p>
		Terminals rules have no constituent rules. They match against a
		character sequence at some offset or they don't. If a grammar has no
		terminal rules, it never makes contact with the underlying character
		sequence and hence can never match.<span class="fn">This state
			of affairs will be found during compilation and a <code>dfh.grammar.GrammarException</code>
			will be thrown, aborting the program. The exception will carry an
			explanatory message such as "cycle found in rules: &lt;b&gt;,
			&lt;a&gt;".
		</span>
	</p>
	<p>During matching, the matcher will cache some information about
		attempted matches by various rules at various offsets in the character
		sequence. For non-terminal rules all that is cached is the success or
		failure of the match. This is to prevent the cache from consuming too
		much memory -- a particular non-terminal rule can potentially match
		exponentially many ways at a given offset. Because the number of
		possible terminal matches is linear in the length of the sequence, the
		whole match object is stored for terminal matches, accelerating the
		match process.</p>
	<h3>Regular Expressions</h3>
	<pre>rule = <b>/</b>^ foo \b<b>/imx</b> </pre>
	<p>
		Any Java regular expression (aside from multi-line expressions with
		the
		<code>x</code>
		modifier) can be placed inside forward slashes and used in a rule.
		Modifiers can either be included inside the slashes like so
	<pre>rule = /(?i:foo)/</pre>
	or appended after the last slash as in Perl.
	<pre>rule = /foo/i</pre>
	</p>
	<h4>Regex modifiers</h4>
	<p>
		Regular expressions can take all the modifiers understood by
		<code>java.util.Pattern</code>
		plus one more:
	</p>
	<table class="dictionary_table">
		<tr>
			<td>i</td>
			<td><code>Pattern.CASE_INSENSITIVE</code></td>
		</tr>
		<tr>
			<td>m</td>
			<td><code>Pattern.MULTILINE</code></td>
		</tr>
		<tr>
			<td>s</td>
			<td><code>Pattern.DOTALL</code></td>
		</tr>
		<tr>
			<td>x</td>
			<td><code>Pattern.COMMENTS</code></td>
		</tr>
		<tr>
			<td>d</td>
			<td><code>Pattern.UNIX_LINES</code></td>
		</tr>
		<tr>
			<td>u</td>
			<td><code>Pattern.UNICODE_CASE</code></td>
		</tr>
		<tr>
			<td>r</td>
			<td>expression is reversible -- if it matches a sequence it will
				also match the reverse of this sequence -- or reversed; so it is
				usable in a lookbehind assertion. In the latter case, where it is
				reversed, <em>it cannot be used except in backwards assertions</em>.
			</td>
		</tr>
	</table>
	<p>
		This last modifier <em>cannot</em> be placed inside the slashes but
		must be appended after.
	</p>
	<h4>Why regular expressions in grammars</h4>
	<p>
		Since a
		<code>dfh.grammar.Grammar</code>
		duplicates almost every capability of a Java regular expression you
		might wonder why these are necessary at all. It is because
		<code>dfh.grammar.Grammar</code>
	<ol>
		<li>lacks anchor constructs -- <code>\b</code> , <code>^</code> ,
			<code>$</code> , <code>\A</code> , <code>\Z</code> and so forth
		</li>
		<li>lacks character classes, which are particularly nice in Java</li>
		<li>lacks modifiers equivalent to <code>Pattern.CASE_INSENSITIVE</code>
			or <code>Pattern.MULTILINE</code>.
		</li>
		<li>If you can make do with the more impoverished pattern
			capturing ability of regular expressions, they're much faster, so the
			more you can rely on them rather than grammars the faster your code
			will be.</li>
		<li>If you have pre-existing regular expressions, it is
			convenient to be able plug them into grammars unchanged.</li>
	</ol>
	</p>
	<h3>Literals</h3>
	<pre>rule1 = <b>'</b>"foo"<b>'</b>
rule2 = <b>"</b>'foo'<b>"</b> </pre>
	<p>String literals are sequences of characters enclosed in double
		or single quotes. Every character in the literal must be identical to
		the corresponding character in the sequence matched against for a
		literal rule to match.</p>
	<h4>Escape sequences</h4>
	<p>
		All the escape sequences that work in Java string literals work in
		<code>dfh.grammar</code>
		string literals.
	</p>
	<h2>External Rule Definition</h2>
	<p>
		You may wish to build grammars compositionally by using one to define
		a rule in another, to plug your own extensions of
		<code>dfh.grammar.Rule</code>
		in, or to build large or variable regular expressions programmatically
		and then plug them into a static grammar. There are two ways to do
		this.
	</p>
	<h3>Pre-loading Rules</h3>
	<p>you may load in a mapping from rule labels to rules in while
		compiling the grammar
	<pre>		Map&lt;String, Rule&gt; map = new HashMap&lt;String, Rule&gt;(1);
		map.put("r", whateverRule);
		String[] rules = {
		//
		"ROOT = ~- &lt;r&gt; 'bar'",//
		};
		Grammar g = new Grammar(rules, map);</pre>
	It is necessary to pre-load rules if you wish to use them in lookbehind
	assertions, as in this example. The compiler needs to confirm that any
	rule in a lookbehind is reversible and it is only able to do this if it
	already has the rules on hand during compilation.
	</p>
	<h3>Deferred Rule Definition</h3>
	<p>If you do not plan to use the rules in lookbehinds you may
		compile a grammar with undefined rules and define these after.
	<pre>		String[] rules = {
		//
		"ROOT = &lt;q&gt; &lt;text&gt; &lt;bar&gt; 1",//
		};
		Grammar g = new Grammar(rules);
		g.defineRule("q", Pattern.compile("[\"']")); // <b>deferred regular expression</b>
		g.defineRule("text", whateverRule);          // <b>deferred arbitrary rule</b>
		g.defineRule("bar","quux");                  // <b>deferred string literal</b>
	</pre>
	As you can see from this example, deferred rule definition is somewhat
	more convenient than pre-loaded rules. For one thing, it is more
	concise and hence easier to read. For another, there are convenience
	methods for defining deferred rules when they are to match literal
	character sequences or regular expressions.
	</p>
	<p>
		Naturally, if you attempt to match a grammar with undefined rules
		against a character sequence a
		<code>dfh.grammar.GrammarException</code>
		will be thrown.
	</p>
	<h2>Conditions</h2>
	<pre>		String[] rules = {
		//
		"ROOT = /\\b\\d++\\b/ <b>(less_than_100)</b>",//
		};
		Grammar g = new Grammar(rules);
		<b>g.defineCondition("less_than_100", new Condition() {
			public boolean passes(Match m, Matcher n, CharSequence s) {
				int i = Integer.parseInt(s.subSequence(m.start(), m.end())
						.toString());
				return i < 100;
			}
		});</b>
		String s = "99 100 1000";
		Matcher m = g.find(s);
		Match n;
		while ((n = m.match()) != null)
			System.out.println(s.substring(n.start(), n.end()));</pre>
	<p>Conditions are perhaps the most powerful feature grammars have
		beyond those they share with regular expressions. These are arbitrary
		tests that can be applied after a rule has matched. The example above
		produces
	<pre class="results">99</pre>
	</p>
	<p>Caution should be taken when using conditions. In particular,
		they should be functional: a condition that matches at a particular
		offset in a character sequence should always match. Do not make
		conditions dependent on unrelated state such as the weather at
		matching time, the phase of the moon, or the contents of a dynamic
		database. To do otherwise would invalidate the results cached when
		matches at this offset are attempted and possibly lead to false
		negatives when matching.</p>
	<p>Also, you may not realize how frequently a condition needs to be
		tested. Matching recursive patterns is exponentially complex. The
		grammar is able to store whether the conditionalized rule ever matches
		at a particular offset but not all the ways it can match. Hence
		conditions are a good way to slow down a match. If you find the
		condition slows down the match unacceptably you may need to remove
		condition testing to a post-processing stage. This has the
		disadvantage that it is less declarative and may require iterating
		over a great many matches in post-processing -- you probably will want
		to iterate over all possible matches, not merely all non-overlapping
		matches. On the other hand, you will most likely need to apply the
		test less often than you would in the midst of matching.</p>
	<h2>Assertions</h2>
	<p>Assertions are in effect special conditions that may appear
		anywhere in a rule. They do not move the character matching offset but
		will cause the rule or match to fail if some condition is not met.</p>
	<h3>Zero-Width Matches</h3>
	<p>Zero-width matches are rules that test whether the characters
		adjacent to the current offset meet some condition. You may define a
		great many of these with ordinary regular expressions:</p>
	<pre>String[] rules = {
        //
        "  ROOT = &lt;matt&gt; &lt;s&gt; &lt;joe&gt; &lt;s&gt; &lt;is_sue&gt;",//
        "   joe = /\\bjoe\\b/i",//
        "is_sue = /(?=sue)/i",//   <b>looks ahead</b>
        "is_mat = /(?&lt;=matt)/i",// <b>looks behind</b>
        "     s = /\\s++/",//
};</pre>
	<p>The problem with doing this this way, though, is that</p>
	<ol>
		<li>you are limited to terminal rules</li>
		<li>your backwards assertions must be fixed-width</li>
	</ol>
	<p>
		So
		<code>dfh.grammar</code>
		provides its own assertion syntax with which you can define assertions
		which are variable width in either direction.
	</p>
	<h4>Lookaheads</h4>
	<pre>String[] rules = {
        //
        "ROOT = &lt;a&gt; /\\s++/ &lt;b&gt; /\\s++/ &lt;c&gt; /\\s++/ &lt;d&gt;",//
        "   a = ~  '1' /\\b\\d++/",// <b>the number must begin with 1</b>
        "   b = ~+ '2' /\\b\\d++/",// <b>long form: the '+' here simply means "forward"</b>
        "   c = !  '3' /\\b\\d++/",// <b>the number must not begin with 3</b>
        "   d = !+ '4' /\\b\\d++/",//
};</pre>
	<p>
		The examples above are silly but they serve to illustrate the syntax.
		A positive assertion has the prefix
		<code>~</code>
		; a negative,
		<code>!</code>
		. You may append the suffix
		<code>+</code>
		to this to make clear that this is a forward assertion: the following
		rule must match at the offset and preceding to the right. And the rule
		marked as an assertion is that immediately after the lookahead symbol.
	</p>
	<h4>Lookbehinds</h4>
	<pre>String[] rules = {
        //
        "ROOT = &lt;a&gt; /\\s++/ &lt;b&gt;",//
        "   a = /\\b\\d++/ ~- '1'",// <b>the number must end in 1</b>
        "   b = /\\b\\d++/ !- '2'",// <b>the number must not end in 2</b>
};</pre>
	<p>
		There is no short form to lookbehinds; they must always carry the
		suffix
		<code>-</code>
		indicating they match backwards from the current offset. Note that you
		do not write the rule backwards that they modify. The grammar compiler
		will do this for you. So for example
	</p>
	<pre>		String[] rules = {
				//
				"ROOT = !- [ &lt;fred&gt; /\\s++/r ] &lt;fred&gt;",//
				"fred = 'fred'",//
		};
		Grammar g = new Grammar(rules);
		String s = "fred fred bob";
		Matcher m = g.find(s);
		Match n;
		while ((n = m.match()) != null)
			System.out.println(n);</pre>
	<p>produces</p>
	<pre class="results">(!-[ &lt;fred&gt; /\s++/r ] &lt;fred&gt;: 0, 4 [(!-[ &lt;fred&gt; /\s++/r ]: 0, 0), ("fred": 0, 4)])</pre>
	<p>
		That is, it only finds the first <i>fred</i>, and the stringification
		of the match keeps the description facing forwards.
	</p>
	<p>
		Note the
		<code>r</code>
		modifier on the regular expression. A regular expression can only be
		used in a backwards assertion if it carries this modifier, which
		simply marks it as reversible. Reversible regular expressions are
		those which only match palindromes. In this case, a block of all the
		same character class will be a palindrome, so it's reversible. This
		powerful restriction on the regular expressions usable in backwards
		assertions actually limits their power very little inasmuch as the
		rest of the machinery of matching can be provided by
		<code>dfh.grammar</code>
		itself.
	</p>
	<b>how it works</b>
	<p>
		Backwards assertions work by wrapping the relevant portion of the
		character sequence in a class that in effect reverses it, so character
		indexes count back from the end and index 0 refers to the last
		character. To this reversed character sequence it applies a rule
		identical to the one defined in your grammar but with all sequences
		reversed, so
		<code>'cat'</code>
		covertly becomes
		<code>'tac'</code>
		. This reversal of the sequences occurs at compilation time and it
		works on a copy of the reversed rule tree, so these same rules can be
		applied in a forward direction elsewhere. Regular expressions, because
		of their branching, back references, directional assertions, and so
		forth, are non-trivial to reverse. Also, one could plug in quite vast
		regular expressions which would take some time to reverse during
		compilation. Furthermore, backreferences make some regular expressions
		virtually impossible to handle by reversing the sequence.
	</p>
	<p>
		The
		<code>r</code>
		modifier on a regular expression marks it as reversible or reversed --
		already written to be used on a reversed sequence. Only palindromic
		regular expressions may be used both inside and outside backwards
		assertions.
	</p>
	<p>Backtracking barriers may produce confusing results if used in a
		backwards assertion. Consider the rules</p>
	<pre>ROOT = ~- &lt;a&gt; 'bar'
   a = 'b'+ : 'bc'</pre>
	<p>
		Looking at rule
		<code>&lt;a&gt;</code>
		it appears that it will always fail to match. First it matches a
		sequence of one or more <i>b</i>s. Then it puts up a barrier to any
		backtracking. Then it attempts to match another <i>b</i>. But it
		already matched all the <i>b</i>s it could find, so it must fail! But
		matching from right to left, as the backwards assertion does, means it
		can grab a <i>b</i> before hitting the barrier. In fact, in this case
		the grammar will match <i>bbcbar</i>.
	</p>
	<h3>Backtracking Barriers</h3>
	A backtracking barrier is a sort of meta-assertion. It says, "the
	matching engine will not have to revisit this decision or anything that
	precedes it." It serves a function similar to the
	<code>(?&gt;&nbsp;...&nbsp;)</code>
	in Perl-compatible regular expressions or possessive quantification. It
	makes matching more tractable by eliminating at one stroke some number
	of permutations in the matching engine's search space.
	<h4>:</h4>
	The single-colon barrier indicates that the rule containing it fails if
	it cannot complete the match after the the barrier without revisiting
	decisions before the barrier. If you know that the first few elements
	in a sequence will match only one way if at all, you can follow them
	with the single-colon barrier.
	<h4>::</h4>
	The double-colon barrier indicates that if the portion of the rule
	after the barrier fails to match then the entire grammar fails to match
	at the current offset in the character sequence.
	<h2>Named Captures</h2>
	<pre>&lt;ROOT&gt; = [<b>{a}</b>'a']++
&lt;ROOT&gt; = [<b>{foo}</b> 'a' /\\s++/ 'b']++ [<b>{bar}</b> 'c'] [<b>{baz,quux}</b> 'd' | 'e']</pre>
	<p>
		Some regular expression engines, such as those of Python, Perl, and
		the PCRE library, provide a syntax for naming captured groups. It
		began with Python, where the syntax was
		<code>(?P&lt;name&gt;pattern)</code>
		. This construction assigns a name to whatever
		<code>pattern</code>
		matches, so later one can fetch it for whatever purpose. Other
		languages then adopted similar syntax for this purpose. Perl, for
		instance, provides
		<code>/(?&lt;name&gt;pattern)/</code>
		. Well, for
		<code>dfh.grammar</code>
		I preferred to use the angle brackets, as in BNF, to label rules, so
		you can assign a label to a group in
		<code>dfh.grammar</code>
		using curly brackets instead, as illustrated above.
	</p>
	<p>
		Unlike these various regular expression engines,
		<code>dfh.grammar</code>
		always captures and returns the entire match tree, so all the matches
		are there regardless of whether you've named them or bracketed them.
		The names merely serve to facilitate finding the bits matched by
		particular rules. Furthermore, every named rule always tags its match
		with its name. The curly bracket notation is chiefly useful for what
		would otherwise be anonymous rules. Also, as illustrated in the second
		example above, you may provide more than one name inside the curly
		brackets -- names have the same restrictions as rule labels; the name
		separator inside the brackets is the comma. This allows you to
		multiply categorize matches, both dates and numbers, say.
	</p>
	<h2>Options</h2>
	<pre>Matcher m = g.find(s);                                               // <b>use all defaults</b>
...
m = g.find(s, new Options().allowOverlap(true).longestMatch(false)); // <b>change two parameters</b>
...
Options opt = new Options().allowOverlap(true).longestMatch(false);  // <b>options are reusable</b>
m = g.find(s2, opt);
...
m = g.find(s3, opt);</pre>
	<p>
		With
		<code>java.regex.Matcher</code>
		matching, one can modify the matching altering various properties of
		the matcher object separately. With
		<code>dfh.grammar</code>
		matching one must pass all the desired options in as a collection when
		creating the matcher. This improves efficiency and ensures the
		immutability of its state aside from its position in the sequence of
		matches over which it is iterating. The parameter collection is an
		instance of
		<code>dfh.grammar.Options</code>
		. Among other things is specifies which should be regarded as the
		first and last characters in the sub-sequence to match against,
		whether overlapping matches should be considered, and whether
		debugging output should be produced.
	</p>
	<h3>start</h3>
	<pre>Options opt = new Options().start(10);
System.out.println(opt.start());       // 10</pre>
	<h3>end</h3>
	<pre>Options opt = new Options().end(10);
System.out.println(opt.end());       // 10</pre>
	<h3>allow overlap</h3>
	<pre>Options opt = new Options().allowOverlap(true);
System.out.println(opt.allowOverlap());         // true</pre>
	<h3>keep rightmost match</h3>
	<pre>Options opt = new Options().keepRightmost(true);
System.out.println(opt.keepRightmost());         // true</pre>
	<h3>longest match</h3>
	<pre>Options opt = new Options().longestMatch(true);
System.out.println(opt.longestMatch());         // true</pre>
	<h3>match all</h3>
	<pre>Options opt = new Options().matchAll(true);
System.out.println(opt.matchAll());         // true</pre>
	<h3>maximum recursion depth</h3>
	<pre>Options opt = new Options().maxRecursionDepth(10);
System.out.println(opt.maxRecursionDepth());       // 10</pre>
	<h3>study</h3>
	<pre>Options opt = new Options().study(false);
System.out.println(opt.study());          // false</pre>
	<h3>trace</h3>
	<pre>Options opt = new Options().trace(System.err);
opt.trace().println(10);                       // 10</pre>
</body>
</html>